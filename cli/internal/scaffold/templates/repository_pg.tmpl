package db

import (
    "database/sql"
    "fmt"

    "{{ .ImportPath }}/internal/domain/entity"
    "{{ .ImportPath }}/internal/domain/repository"
    pdb "{{ .ImportPath }}/pkg/db"
)

type Postgres{{ .EntityName }}Repository struct { db pdb.DBExecutor }

func NewPostgres{{ .EntityName }}Repository(db pdb.DBExecutor) *Postgres{{ .EntityName }}Repository {
    return &Postgres{{ .EntityName }}Repository{db: db}
}

var _ repository.{{ .EntityName }}Repository = (*Postgres{{ .EntityName }}Repository)(nil)

func (r *Postgres{{ .EntityName }}Repository) FindByID(id string) (*entity.{{ .EntityName }}, error) {
    const q = `SELECT id{{range .Fields}}, {{.ColumnName}}{{end}}, created_at FROM {{ .PluralSnake }} WHERE id = $1`
    row := r.db.QueryRow(q, id)
    var e entity.{{ .EntityName }}
    if err := row.Scan(&e.ID{{range .Fields}}, &e.{{.Name}}{{end}}, &e.CreatedAt); err != nil {
        return nil, err
    }
    return &e, nil
}

func (r *Postgres{{ .EntityName }}Repository) Save(e *entity.{{ .EntityName }}) error {
    const q = `INSERT INTO {{ .PluralSnake }} (id{{range .Fields}}, {{.ColumnName}}{{end}}, created_at) VALUES ($1{{range $i, $f := .Fields}}, ${{add $i 2}}{{end}}, ${{add (len .Fields) 2}})`
    _, err := r.db.Exec(q, e.ID{{range .Fields}}, e.{{.Name}}{{end}}, e.CreatedAt)
    return err
}

func (r *Postgres{{ .EntityName }}Repository) Update(id string, e *entity.{{ .EntityName }}) error {
    const q = `UPDATE {{ .PluralSnake }} SET {{range $i, $f := .Fields}}{{if $i}}, {{end}}{{ $f.ColumnName }} = ${{add $i 1}}{{end}} WHERE id = ${{add (len .Fields) 1}}`
    _, err := r.db.Exec(q{{range .Fields}}, e.{{.Name}}{{end}}, id)
    return err
}

func (r *Postgres{{ .EntityName }}Repository) Delete(id string) error {
    const q = `DELETE FROM {{ .PluralSnake }} WHERE id = $1`
    _, err := r.db.Exec(q, id)
    return err
}

func (r *Postgres{{ .EntityName }}Repository) List(filters map[string]interface{}) ([]*entity.{{ .EntityName }}, error) {
    base := `SELECT id{{range .Fields}}, {{.ColumnName}}{{end}}, created_at FROM {{ .PluralSnake }}`
    args := []any{}
    allowed := map[string]struct{}{ {{range .Fields}}"{{ .ColumnName }}": {}, {{end}} }
    i := 1
    for k, v := range filters {
        if _, ok := allowed[k]; !ok { continue }
        if len(args) == 0 {
            base += " WHERE "
        } else {
            base += " AND "
        }
        base += fmt.Sprintf("%s = $%d", k, i)
        args = append(args, v)
        i++
    }
    rows, err := r.db.Query(base, args...)
    if err != nil { return nil, err }
    defer rows.Close()

    var list []*entity.{{ .EntityName }}
    for rows.Next() {
        var e entity.{{ .EntityName }}
        if err := rows.Scan(&e.ID{{range .Fields}}, &e.{{.Name}}{{end}}, &e.CreatedAt); err != nil {
            return nil, err
        }
        list = append(list, &e)
    }
    return list, rows.Err()
}
